ğŸ§ª Testing Custom Port Configuration System
===========================================
ğŸ“ Testing apps from config.json:
ğŸ” Testing port configuration for: example-app-1
-------------------------------------------
ğŸ“‹ Configuration loaded:
   APP_NAME: example-app-1
   DOCKER_PORT: 3000 (container port)
   SERVICE_PORT: 80 (service port - user access port)
   NODE_PORT: 30001 (kubernetes nodeport)
   DOMAIN: example-app-1.example.com
ğŸŒ Generated Service YAML:
=========================
apiVersion: v1
kind: Service
metadata:
  name: example-app-1-service
spec:
  type: NodePort
  selector:
    app: example-app-1
    version: blue
  ports:
    - protocol: TCP
      port: 80
      targetPort: 3000
      nodePort: 30001
ğŸŒ Generated Ingress YAML:
=========================
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: example-app-1-ingress
  annotations:
    cert-manager.io/cluster-issuer: letsencrypt-prod
    nginx.ingress.kubernetes.io/rewrite-target: /
    nginx.ingress.kubernetes.io/backend-protocol: "HTTP"
    nginx.ingress.kubernetes.io/proxy-connect-timeout: "600"
    nginx.ingress.kubernetes.io/proxy-send-timeout: "600"
    nginx.ingress.kubernetes.io/proxy-read-timeout: "600"
spec:
  ingressClassName: public
  tls:
    - hosts:
        - example-app-1.example.com
      secretName: example-app-1-tls
  rules:
    - host: example-app-1.example.com
      http:
        paths:
          - path: /
            pathType: Prefix
            backend:
              service:
                name: example-app-1-service
                port:
                  number: 80
âœ… Test completed for example-app-1
   ğŸ”— Port Flow:
   - User accesses: https://example-app-1.example.com (via ingress)
   - Ingress routes to: example-app-1-service:80
   - Service forwards to: container:3000
   - Direct NodePort access: <node-ip>:30001
   ğŸ¯ Custom Port Configuration:
   - User can access app on custom port: 80
   - This allows flexibility: port 80, 3000, 3001, etc.
ğŸ” Testing port configuration for: example-app-2
-------------------------------------------
ğŸ“‹ Configuration loaded:
   APP_NAME: example-app-2
   DOCKER_PORT: 8080 (container port)
   SERVICE_PORT: 3000 (service port - user access port)
   NODE_PORT: 30002 (kubernetes nodeport)
   DOMAIN: example-app-2.example.com
ğŸŒ Generated Service YAML:
=========================
apiVersion: v1
kind: Service
metadata:
  name: example-app-2-service
spec:
  type: NodePort
  selector:
    app: example-app-2
    version: blue
  ports:
    - protocol: TCP
      port: 3000
      targetPort: 8080
      nodePort: 30002
ğŸŒ Generated Ingress YAML:
=========================
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: example-app-2-ingress
  annotations:
    cert-manager.io/cluster-issuer: letsencrypt-prod
    nginx.ingress.kubernetes.io/rewrite-target: /
    nginx.ingress.kubernetes.io/backend-protocol: "HTTP"
    nginx.ingress.kubernetes.io/proxy-connect-timeout: "600"
    nginx.ingress.kubernetes.io/proxy-send-timeout: "600"
    nginx.ingress.kubernetes.io/proxy-read-timeout: "600"
spec:
  ingressClassName: public
  tls:
    - hosts:
        - example-app-2.example.com
      secretName: example-app-2-tls
  rules:
    - host: example-app-2.example.com
      http:
        paths:
          - path: /
            pathType: Prefix
            backend:
              service:
                name: example-app-2-service
                port:
                  number: 3000
âœ… Test completed for example-app-2
   ğŸ”— Port Flow:
   - User accesses: https://example-app-2.example.com (via ingress)
   - Ingress routes to: example-app-2-service:3000
   - Service forwards to: container:8080
   - Direct NodePort access: <node-ip>:30002
   ğŸ¯ Custom Port Configuration:
   - User can access app on custom port: 3000
   - This allows flexibility: port 80, 3000, 3001, etc.
ğŸ” Testing port configuration for: example-app-3
-------------------------------------------
ğŸ“‹ Configuration loaded:
   APP_NAME: example-app-3
   DOCKER_PORT: 5000 (container port)
   SERVICE_PORT: 3001 (service port - user access port)
   NODE_PORT: 30003 (kubernetes nodeport)
   DOMAIN: example-app-3.example.com
ğŸŒ Generated Service YAML:
=========================
apiVersion: v1
kind: Service
metadata:
  name: example-app-3-service
spec:
  type: NodePort
  selector:
    app: example-app-3
    version: blue
  ports:
    - protocol: TCP
      port: 3001
      targetPort: 5000
      nodePort: 30003
ğŸŒ Generated Ingress YAML:
=========================
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: example-app-3-ingress
  annotations:
    cert-manager.io/cluster-issuer: letsencrypt-prod
    nginx.ingress.kubernetes.io/rewrite-target: /
    nginx.ingress.kubernetes.io/backend-protocol: "HTTP"
    nginx.ingress.kubernetes.io/proxy-connect-timeout: "600"
    nginx.ingress.kubernetes.io/proxy-send-timeout: "600"
    nginx.ingress.kubernetes.io/proxy-read-timeout: "600"
spec:
  ingressClassName: public
  tls:
    - hosts:
        - example-app-3.example.com
      secretName: example-app-3-tls
  rules:
    - host: example-app-3.example.com
      http:
        paths:
          - path: /
            pathType: Prefix
            backend:
              service:
                name: example-app-3-service
                port:
                  number: 3001
âœ… Test completed for example-app-3
   ğŸ”— Port Flow:
   - User accesses: https://example-app-3.example.com (via ingress)
   - Ingress routes to: example-app-3-service:3001
   - Service forwards to: container:5000
   - Direct NodePort access: <node-ip>:30003
   ğŸ¯ Custom Port Configuration:
   - User can access app on custom port: 3001
   - This allows flexibility: port 80, 3000, 3001, etc.
ğŸ‰ All tests completed!
======================
ğŸ“ Summary:
- Users can now specify custom servicePort in config.json
- example-app-1: accessible on port 80 (standard web port)
- example-app-2: accessible on port 3000 (custom port)
- example-app-3: accessible on port 3001 (custom port)
- The system automatically configures ingress and service to route to the specified ports
- This solves the requirement: users can access apps on ports 80, 3000, 3001, etc.